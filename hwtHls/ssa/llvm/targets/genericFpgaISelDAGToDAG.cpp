//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the GenericFpga target.
//
//===----------------------------------------------------------------------===//

#include <llvm/CodeGen/MachineRegisterInfo.h>
#include <llvm/CodeGen/SelectionDAGISel.h>
#include <llvm/Support/Debug.h>
#include <llvm/Support/raw_ostream.h>

#include "genericFpgaISelDAGToDAG.h"
#include "genericFpgaTargetMachine.h"
#include "genericFpgaMCTargetDesc.h"

#define DEBUG_TYPE "genericfpga-isel"

namespace llvm {

/// Lowers LLVM IR (in DAG form) to GenericFpga MC instructions (in DAG form).
class GenericFpgaDAGToDAGISel: public SelectionDAGISel {
public:
	GenericFpgaDAGToDAGISel(llvm::GenericFpgaTargetMachine &TM,
			CodeGenOpt::Level OptLevel) :
			SelectionDAGISel(TM, OptLevel), Subtarget(nullptr) {
	}

	StringRef getPassName() const override {
		return "GenericFpga DAG->DAG Instruction Selection";
	}

	bool runOnMachineFunction(MachineFunction &MF) override;

	bool SelectAddr(SDNode *Op, SDValue N, SDValue &Base, SDValue &Disp);

	bool selectIndexedLoad(SDNode *N);
	unsigned selectIndexedProgMemLoad(const LoadSDNode *LD, MVT VT);

	bool SelectInlineAsmMemoryOperand(const SDValue &Op,
			unsigned ConstraintCode, std::vector<SDValue> &OutOps) override;

// Include the pieces autogenerated from the target description.
#include "GenericFpgaGenDAGISel.inc"

private:
	void Select(SDNode *N) override;
	bool trySelect(SDNode *N);

	template<unsigned NodeType> bool select(SDNode *N);
	bool selectMultiplication(SDNode *N);

	const GenericFpgaTargetSubtarget *Subtarget;
};

bool GenericFpgaDAGToDAGISel::runOnMachineFunction(MachineFunction &MF) {
	Subtarget = &MF.getSubtarget<GenericFpgaTargetSubtarget>();
	return SelectionDAGISel::runOnMachineFunction(MF);
}

bool GenericFpgaDAGToDAGISel::SelectAddr(SDNode *Op, SDValue N, SDValue &Base,
		SDValue &Disp) {
	SDLoc dl(Op);
	auto DL = CurDAG->getDataLayout();
	MVT PtrVT = getTargetLowering()->getPointerTy(DL);

	// if the address is a frame index get the TargetFrameIndex.
	if (const FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(N)) {
		Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), PtrVT);
		Disp = CurDAG->getTargetConstant(0, dl, MVT::i8);

		return true;
	}

	// Match simple Reg + uimm6 operands.
	if (N.getOpcode() != ISD::ADD && N.getOpcode() != ISD::SUB
			&& !CurDAG->isBaseWithConstantOffset(N)) {
		return false;
	}

	if (const ConstantSDNode *RHS = dyn_cast<ConstantSDNode>(N.getOperand(1))) {
		int RHSC = (int) RHS->getZExtValue();

		// Convert negative offsets into positives ones.
		if (N.getOpcode() == ISD::SUB) {
			RHSC = -RHSC;
		}

		// <#Frame index + const>
		// Allow folding offsets bigger than 63 so the frame pointer can be used
		// directly instead of copying it around by adjusting and restoring it for
		// each access.
		if (N.getOperand(0).getOpcode() == ISD::FrameIndex) {
			int FI = cast<FrameIndexSDNode>(N.getOperand(0))->getIndex();

			Base = CurDAG->getTargetFrameIndex(FI, PtrVT);
			Disp = CurDAG->getTargetConstant(RHSC, dl, MVT::i16);

			return true;
		}

		// The value type of the memory instruction determines what is the maximum
		// offset allowed.
		MVT VT = cast<MemSDNode>(Op)->getMemoryVT().getSimpleVT();

		// We only accept offsets that fit in 6 bits (unsigned).
		if (isUInt<6>(RHSC) && (VT == MVT::i8 || VT == MVT::i16)) {
			Base = N.getOperand(0);
			Disp = CurDAG->getTargetConstant(RHSC, dl, MVT::i8);

			return true;
		}
	}

	return false;
}

bool GenericFpgaDAGToDAGISel::selectIndexedLoad(SDNode *N) {
	const LoadSDNode *LD = cast<LoadSDNode>(N);
	ISD::MemIndexedMode AM = LD->getAddressingMode();
	MVT VT = LD->getMemoryVT().getSimpleVT();
	auto PtrVT = getTargetLowering()->getPointerTy(CurDAG->getDataLayout());

	// We only care if this load uses a POSTINC or PREDEC mode.
	if ((LD->getExtensionType() != ISD::NON_EXTLOAD)
			|| (AM != ISD::POST_INC && AM != ISD::PRE_DEC)) {

		return false;
	}

	unsigned Opcode = 0;
	//bool isPre = (AM == ISD::PRE_DEC);
	//int Offs = cast<ConstantSDNode>(LD->getOffset())->getSExtValue();

	//switch (VT.SimpleTy) {
	//case MVT::i8: {
	//  if ((!isPre && Offs != 1) || (isPre && Offs != -1)) {
	//    return false;
	//  }
	//
	//  Opcode = (isPre) ? GenericFpga::LDRdPtrPd : GenericFpga::LDRdPtrPi;
	//  break;
	//}
	//case MVT::i16: {
	//  if ((!isPre && Offs != 2) || (isPre && Offs != -2)) {
	//    return false;
	//  }
	//
	//  Opcode = (isPre) ? GenericFpga::LDWRdPtrPd : GenericFpga::LDWRdPtrPi;
	//  break;
	//}
	//default:
	//  return false;
	//}
	return false;

	SDNode *ResNode = CurDAG->getMachineNode(Opcode, SDLoc(N), VT, PtrVT,
			MVT::Other, LD->getBasePtr(), LD->getChain());
	ReplaceUses(N, ResNode);
	CurDAG->RemoveDeadNode(N);

	return true;
}

unsigned GenericFpgaDAGToDAGISel::selectIndexedProgMemLoad(const LoadSDNode *LD,
		MVT VT) {
	ISD::MemIndexedMode AM = LD->getAddressingMode();

	// Progmem indexed loads only work in POSTINC mode.
	if (LD->getExtensionType() != ISD::NON_EXTLOAD || AM != ISD::POST_INC) {
		return 0;
	}

	unsigned Opcode = 0;
	//int Offs = cast<ConstantSDNode>(LD->getOffset())->getSExtValue();

	//switch (VT.SimpleTy) {
	//case MVT::i8: {
	//  if (Offs != 1) {
	//    return 0;
	//  }
	//  Opcode = GenericFpga::LPMRdZPi;
	//  break;
	//}
	//case MVT::i16: {
	//  if (Offs != 2) {
	//    return 0;
	//  }
	//  Opcode = GenericFpga::LPMWRdZPi;
	//  break;
	//}
	//default:
	//  return 0;
	//}

	return Opcode;
}

bool GenericFpgaDAGToDAGISel::SelectInlineAsmMemoryOperand(const SDValue &Op,
		unsigned ConstraintCode, std::vector<SDValue> &OutOps) {
	assert(
			(ConstraintCode == InlineAsm::Constraint_m
					|| ConstraintCode == InlineAsm::Constraint_Q)
					&& "Unexpected asm memory constraint");

	//MachineRegisterInfo &RI = MF->getRegInfo();
	//const GenericFpgaSubtarget &STI = MF->getSubtarget<GenericFpgaSubtarget>();
	//const TargetLowering &TL = *STI.getTargetLowering();
	//SDLoc dl(Op);
	//auto DL = CurDAG->getDataLayout();
	//
	//const RegisterSDNode *RegNode = dyn_cast<RegisterSDNode>(Op);

	// If address operand is of PTRDISPREGS class, all is OK, then.
	//if (RegNode &&
	//    RI.getRegClass(RegNode->getReg()) == &GenericFpga::PTRDISPREGSRegClass) {
	//  OutOps.push_back(Op);
	//  return false;
	//}

	//if (Op->getOpcode() == ISD::FrameIndex) {
	//  SDValue Base, Disp;
	//
	//  if (SelectAddr(Op.getNode(), Op, Base, Disp)) {
	//    OutOps.push_back(Base);
	//    OutOps.push_back(Disp);
	//
	//    return false;
	//  }
	//
	//  return true;
	//}

	//// If Op is add 'register, immediate' and
	//// register is either virtual register or register of PTRDISPREGSRegClass
	//if (Op->getOpcode() == ISD::ADD || Op->getOpcode() == ISD::SUB) {
	//  SDValue CopyFromRegOp = Op->getOperand(0);
	//  SDValue ImmOp = Op->getOperand(1);
	//  ConstantSDNode *ImmNode = dyn_cast<ConstantSDNode>(ImmOp);
	//
	//  unsigned Reg;
	//  bool CanHandleRegImmOpt = ImmNode && ImmNode->getAPIntValue().ult(64);
	//
	//  if (CopyFromRegOp->getOpcode() == ISD::CopyFromReg) {
	//    RegisterSDNode *RegNode =
	//        cast<RegisterSDNode>(CopyFromRegOp->getOperand(1));
	//    Reg = RegNode->getReg();
	//    CanHandleRegImmOpt &= (Register::isVirtualRegister(Reg) ||
	//                           GenericFpga::PTRDISPREGSRegClass.contains(Reg));
	//  } else {
	//    CanHandleRegImmOpt = false;
	//  }
	//
	//  // If we detect proper case - correct virtual register class
	//  // if needed and go to another inlineasm operand.
	//  if (CanHandleRegImmOpt) {
	//    SDValue Base, Disp;
	//
	//    if (RI.getRegClass(Reg) != &GenericFpga::PTRDISPREGSRegClass) {
	//      SDLoc dl(CopyFromRegOp);
	//
	//      Register VReg = RI.createVirtualRegister(&GenericFpga::PTRDISPREGSRegClass);
	//
	//      SDValue CopyToReg =
	//          CurDAG->getCopyToReg(CopyFromRegOp, dl, VReg, CopyFromRegOp);
	//
	//      SDValue NewCopyFromRegOp =
	//          CurDAG->getCopyFromReg(CopyToReg, dl, VReg, TL.getPointerTy(DL));
	//
	//      Base = NewCopyFromRegOp;
	//    } else {
	//      Base = CopyFromRegOp;
	//    }
	//
	//    if (ImmNode->getValueType(0) != MVT::i8) {
	//      Disp = CurDAG->getTargetConstant(ImmNode->getAPIntValue().getZExtValue(), dl, MVT::i8);
	//    } else {
	//      Disp = ImmOp;
	//    }
	//
	//    OutOps.push_back(Base);
	//    OutOps.push_back(Disp);
	//
	//    return false;
	//  }
	//}
	//
	//// More generic case.
	//// Create chain that puts Op into pointer register
	//// and return that register.
	//Register VReg = RI.createVirtualRegister(&GenericFpga::PTRDISPREGSRegClass);
	//
	//SDValue CopyToReg = CurDAG->getCopyToReg(Op, dl, VReg, Op);
	//SDValue CopyFromReg =
	//    CurDAG->getCopyFromReg(CopyToReg, dl, VReg, TL.getPointerTy(DL));
	//
	//OutOps.push_back(CopyFromReg);

	return false;
}

bool GenericFpgaDAGToDAGISel::selectMultiplication(llvm::SDNode *N) {
	return false;
	//SDLoc DL(N);
	//MVT Type = N->getSimpleValueType(0);
	//
	//assert(Type == MVT::i8 && "unexpected value type");
	//
	//bool isSigned = N->getOpcode() == ISD::SMUL_LOHI;
	//unsigned MachineOp = isSigned ? AVR::MULSRdRr : AVR::MULRdRr;
	//
	//SDValue Lhs = N->getOperand(0);
	//SDValue Rhs = N->getOperand(1);
	//SDNode *Mul = CurDAG->getMachineNode(MachineOp, DL, MVT::Glue, Lhs, Rhs);
	//SDValue InChain = CurDAG->getEntryNode();
	//SDValue InGlue = SDValue(Mul, 0);
	//
	//// Copy the low half of the result, if it is needed.
	//if (N->hasAnyUseOfValue(0)) {
	//  SDValue CopyFromLo =
	//      CurDAG->getCopyFromReg(InChain, DL, AVR::R0, Type, InGlue);
	//
	//  ReplaceUses(SDValue(N, 0), CopyFromLo);
	//
	//  InChain = CopyFromLo.getValue(1);
	//  InGlue = CopyFromLo.getValue(2);
	//}
	//
	//// Copy the high half of the result, if it is needed.
	//if (N->hasAnyUseOfValue(1)) {
	//  SDValue CopyFromHi =
	//      CurDAG->getCopyFromReg(InChain, DL, AVR::R1, Type, InGlue);
	//
	//  ReplaceUses(SDValue(N, 1), CopyFromHi);
	//
	//  InChain = CopyFromHi.getValue(1);
	//  InGlue = CopyFromHi.getValue(2);
	//}
	//
	//CurDAG->RemoveDeadNode(N);
	//
	//// We need to clear R1. This is currently done (dirtily)
	//// using a custom inserter.
	//
	//return true;
}

void GenericFpgaDAGToDAGISel::Select(SDNode *N) {
	// If we have a custom node, we already have selected!
	if (N->isMachineOpcode()) {
		LLVM_DEBUG(errs() << "== "; N->dump(CurDAG); errs() << "\n");
		N->setNodeId(-1);
		return;
	}

	// See if subclasses can handle this node.
	if (trySelect(N))
		return;

	// Select the default instruction
	SelectCode(N);
}

bool GenericFpgaDAGToDAGISel::trySelect(SDNode *N) {
	unsigned Opcode = N->getOpcode();
	SDLoc DL(N);

	switch (Opcode) {
	// Nodes we fully handle.
	//case ISD::FrameIndex: return select<ISD::FrameIndex>(N);
	//case ISD::BRIND:      return select<ISD::BRIND>(N);
	case ISD::Constant:
		return true;
	case ISD::UMUL_LOHI:
	case ISD::SMUL_LOHI:
		return selectMultiplication(N);

		// Nodes we handle partially. Other cases are autogenerated
		//case ISD::STORE:   return select<ISD::STORE>(N);
		//case ISD::LOAD:    return select<ISD::LOAD>(N);
		//case GenericFpgaISD::CALL: return select<GenericFpgaISD::CALL>(N);
	default:
		return false;
	}
}


llvm::FunctionPass* createGenericFpgaISelDag(GenericFpgaTargetMachine &TM,
		llvm::CodeGenOpt::Level OptLevel) {
	return new llvm::GenericFpgaDAGToDAGISel(TM, OptLevel);
}

}

