#include "genericFpgaTargetPassConfig.h"

#include "Transforms/hwtHlsCodeGenPrepare.h"
#include "genericFpgaISelDAGToDAG.h"

using namespace llvm;

namespace llvm {

void GenericFpgaTargetPassConfig::addCodeGenPrepare() {
	if (getOptLevel() != llvm::CodeGenOpt::None)
		addPass(new hwtHls::HwtHlsCodeGenPrepare());
}
bool GenericFpgaTargetPassConfig::addInstSelector() {
	// No instruction selector to install.
	addPass(
			createGenericFpgaISelDag(getGenericFpgaTargetMachine(),
					getOptLevel()));
	return false;
}
void GenericFpgaTargetPassConfig::addMachinePasses() {
	//AddingMachinePasses = true;

	// Add passes that optimize machine instructions in SSA form.
//	if (getOptLevel() != CodeGenOpt::None) {
//		addMachineSSAOptimization();
	// Pre-ra tail duplication.
	//addPass(&EarlyTailDuplicateID);

	// Optimize PHIs before DCE: removing dead PHI cycles may make more
	// instructions dead.
	//addPass(&OptimizePHIsID);

	// This pass merges large allocas. StackSlotColoring is a different pass
	// which merges spill slots.
	//addPass(&StackColoringID);

	// If the target requests it, assign local variables to stack slots relative
	// to one another and simplify frame index references where possible.
	//addPass(&LocalStackSlotAllocationID);

	// With optimization, dead code should already be eliminated. However
	// there is one known exception: lowered code for arguments that are only
	// used by tail calls, where the tail calls reuse the incoming stack
	// arguments directly (see t11 in test/CodeGen/X86/sibcall.ll).
	//addPass(&DeadMachineInstructionElimID);
	//
	// Allow targets to insert passes that improve instruction level parallelism,
	// like if-conversion. Such passes will typically need dominator trees and
	// loop info, just like LICM and CSE below.
	//addILPOpts();

	//addPass(&EarlyMachineLICMID);
	//addPass(&MachineCSEID);
	//
	//addPass(&MachineSinkingID);
	//
	//addPass(&PeepholeOptimizerID);
	// Clean-up the dead code that may have been generated by peephole
	// rewriting.
	//addPass(&DeadMachineInstructionElimID);

//	} else {
//		// If the target requests it, assign local variables to stack slots relative
//		// to one another and simplify frame index references where possible.
//		addPass(&LocalStackSlotAllocationID);
//	}
//
//	if (TM->Options.EnableIPRA)
//		addPass(createRegUsageInfoPropPass());
//
//	// Run pre-ra passes.
//	addPreRegAlloc();
//
//	// Debugifying the register allocator passes seems to provoke some
//	// non-determinism that affects CodeGen and there doesn't seem to be a point
//	// where it becomes safe again so stop debugifying here.
//	//DebugifyIsSafe = false;
//
//	// Run register allocation and passes that are tightly coupled with it,
//	// including phi elimination and scheduling.
//	if (getOptimizeRegAlloc())
//		addOptimizedRegAlloc();
//	else
//		addFastRegAlloc();
//
//	// Run post-ra passes.
//	addPostRegAlloc();
//
//	addPass(&RemoveRedundantDebugValuesID, false);
//
//	addPass(&FixupStatepointCallerSavedID);
//
//	// Insert prolog/epilog code.  Eliminate abstract frame index references...
//	if (getOptLevel() != CodeGenOpt::None) {
//		addPass(&PostRAMachineSinkingID);
//		addPass(&ShrinkWrapID);
//	}
//
//	// Prolog/Epilog inserter needs a TargetMachine to instantiate. But only
//	// do so if it hasn't been disabled, substituted, or overridden.
////	if (!isPassSubstitutedOrOverridden(&PrologEpilogCodeInserterID))
////		addPass(createPrologEpilogInserterPass());
////
//	/// Add passes that optimize machine instructions after register allocation.
//	if (getOptLevel() != CodeGenOpt::None)
//		addMachineLateOptimization();
//
//	// Expand pseudo instructions before second scheduling pass.
//	addPass(&ExpandPostRAPseudosID);
//
//	// Run pre-sched2 passes.
//	addPreSched2();
//
//	//if (EnableImplicitNullChecks)
//	//  addPass(&ImplicitNullChecksID);
//
//	// Second pass scheduler.
//	// Let Target optionally insert this pass by itself at some other
//	// point.
//	if (getOptLevel() != CodeGenOpt::None
//			&& !TM->targetSchedulesPostRAScheduling()) {
//		//if (MISchedPostRA)
//		//  addPass(&PostMachineSchedulerID);
//		//else
//		addPass(&PostRASchedulerID);
//	}
//
//	// GC
//	if (addGCPasses()) {
//		//if (PrintGCInfo)
//		//  addPass(createGCInfoPrinter(dbgs()), false);
//	}
//
//	// Basic block placement.
//	if (getOptLevel() != CodeGenOpt::None)
//		addBlockPlacement();
//
//	// Insert before XRay Instrumentation.
//	addPass(&FEntryInserterID);
//
//	addPass(&XRayInstrumentationID);
//	addPass(&PatchableFunctionID);
//
//	if (EnableFSDiscriminator) //  && !FSNoFinalDiscrim
//		// Add FS discriminators here so that all the instruction duplicates
//		// in different BBs get their own discriminators. With this, we can "sum"
//		// the SampleFDO counters instead of using MAX. This will improve the
//		// SampleFDO profile quality.
//		addPass(
//				createMIRAddFSDiscriminatorsPass(
//						sampleprof::FSDiscriminatorPass::PassLast));
//
//	addPreEmitPass();
//
//	if (TM->Options.EnableIPRA)
//		// Collect register usage information and produce a register mask of
//		// clobbered registers, to be used to optimize call sites.
//		addPass(createRegUsageInfoCollector());
//
//	// FIXME: Some backends are incompatible with running the verifier after
//	// addPreEmitPass.  Maybe only pass "false" here for those targets?
//	addPass(&FuncletLayoutID, false);
//
//	addPass(&StackMapLivenessID, false);
//	addPass(&LiveDebugValuesID, false);
//
//	//if (TM->Options.EnableMachineOutliner && getOptLevel() != CodeGenOpt::None &&
//	//    EnableMachineOutliner != RunOutliner::NeverOutline) {
//	//  bool RunOnAllFunctions =
//	//      (EnableMachineOutliner == RunOutliner::AlwaysOutline);
//	//  bool AddOutliner =
//	//      RunOnAllFunctions || TM->Options.SupportsDefaultOutlining;
//	//  if (AddOutliner)
//	//    addPass(createMachineOutlinerPass(RunOnAllFunctions));
//	//}
//
//	// Machine function splitter uses the basic block sections feature. Both
//	// cannot be enabled at the same time. Basic block sections takes precedence.
//	// FIXME: In principle, BasicBlockSection::Labels and splitting can used
//	// together. Update this check once we have addressed any issues.
//	//if (TM->getBBSectionsType() != llvm::BasicBlockSection::None) {
//	//  addPass(llvm::createBasicBlockSectionsPass(TM->getBBSectionsFuncListBuf()));
//	//} else if (TM->Options.EnableMachineFunctionSplitter ||
//	//           EnableMachineFunctionSplitter) {
//	//  addPass(createMachineFunctionSplitterPass());
//	//}
//
//	// Add passes that directly emit MI after all other MI passes.
//	addPreEmitPass2();
//
//	// Insert pseudo probe annotation for callsite profiling
//	if (TM->Options.PseudoProbeForProfiling)
//		addPass(createPseudoProbeInserter());

	//AddingMachinePasses = false;
}

}
