#include "genericFpgaInstructionSelector.h"
#include <llvm/CodeGen/GlobalISel/InstructionSelectorImpl.h>
#include <llvm/CodeGen/GlobalISel/MachineIRBuilder.h>
#include <llvm/Support/Debug.h>

#include "../genericFpgaInstrInfo.h"

#define DEBUG_TYPE "genericfpga-isel"

using namespace llvm;

#define GET_GLOBALISEL_PREDICATE_BITSET
#include "GenericFpgaGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATE_BITSET

class GenericFpgaTargetInstructionSelector: public InstructionSelector {
public:
	GenericFpgaTargetInstructionSelector(const GenericFpgaTargetMachine &TM,
			const GenericFpgaTargetSubtarget &STI,
			const GenericFpgaRegisterBankInfo &RBI);

	bool select(MachineInstr &I) override;
	static const char* getName() {
		return DEBUG_TYPE;
	}

private:
	bool finalizeReplacementOfInstruction(MachineInstrBuilder &MIB,
			MachineInstr &I);
	bool selectImpl(MachineInstr &I, CodeGenCoverage &CoverageInfo) const;
	bool select_G_SHL(MachineFunction &MF, MachineRegisterInfo &MRI,
			MachineIRBuilder &MIRB, MachineInstr &I);
	bool select_G_SEXT(MachineFunction &MF, MachineRegisterInfo &MRI,
			MachineIRBuilder &MIRB, MachineInstr &I);
	bool select_G_ZEXT(MachineFunction &MF, MachineRegisterInfo &MRI,
			MachineIRBuilder &MIRB, MachineInstr &I);
	bool select_G_LOAD_or_G_STORE(MachineFunction &MF, MachineRegisterInfo &MRI,
			MachineIRBuilder &MIRB, MachineInstr &I);
	const GenericFpgaTargetSubtarget &STI;
	const llvm::GenericFpgaInstrInfo &TII;
	const GenericFpgaRegisterInfo &TRI;
	const GenericFpgaRegisterBankInfo &RBI;

	// FIXME: This is necessary because DAGISel uses "Subtarget->" and GlobalISel
	// uses "STI." in the code generated by TableGen. We need to unify the name of
	// Subtarget variable.
	const GenericFpgaTargetSubtarget *Subtarget = &STI;

#define GET_GLOBALISEL_PREDICATES_DECL
#include "GenericFpgaGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_DECL

#define GET_GLOBALISEL_TEMPORARIES_DECL
#include "GenericFpgaGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_DECL
};

#define GET_GLOBALISEL_IMPL
#include "GenericFpgaGenGlobalISel.inc"
#undef GET_GLOBALISEL_IMPL

GenericFpgaTargetInstructionSelector::GenericFpgaTargetInstructionSelector(
		const GenericFpgaTargetMachine &TM, const GenericFpgaTargetSubtarget &STI,
		const GenericFpgaRegisterBankInfo &RBI)
: InstructionSelector(), STI(STI), TII(*dynamic_cast<const GenericFpgaInstrInfo*>(STI.getInstrInfo())),
TRI(*dynamic_cast<const GenericFpgaRegisterInfo*>(STI.getRegisterInfo())), RBI(RBI),

#define GET_GLOBALISEL_PREDICATES_INIT
#include "GenericFpgaGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_INIT
#define GET_GLOBALISEL_TEMPORARIES_INIT
#include "GenericFpgaGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_INIT
{
}

bool constrainInstRegOperands(MachineInstr &I, const TargetInstrInfo &TII,
		const TargetRegisterInfo &TRI, const RegisterBankInfo &RBI) {
	MachineBasicBlock &MBB = *I.getParent();
	MachineFunction &MF = *MBB.getParent();
	MachineRegisterInfo &MRI = MF.getRegInfo();

	for (unsigned OpI = 0, OpE = I.getNumExplicitOperands(); OpI != OpE;
			++OpI) {
		MachineOperand &MO = I.getOperand(OpI);

		// There's nothing to be done on non-register operands.
		if (!MO.isReg())
			continue;

		LLVM_DEBUG(dbgs() << "Converting operand: " << MO << '\n');
		assert(MO.isReg() && "Unsupported non-reg operand");

		Register Reg = MO.getReg();
		// Physical registers don't need to be constrained.
		if (Register::isPhysicalRegister(Reg))
			continue;

		// Register operands with a value of 0 (e.g. predicate operands) don't need
		// to be constrained.
		if (Reg == 0)
			continue;

		// If the operand is a vreg, we should constrain its regclass, and only
		// insert COPYs if that's impossible.
		// constrainOperandRegClass does that for us.
		constrainOperandRegClass(MF, TRI, MRI, TII, RBI, I, I.getDesc(), MO,
				OpI);

		// Tie uses to defs as indicated in MCInstrDesc if this hasn't already been
		// done.
		if (MO.isUse()) {
			int DefIdx = I.getDesc().getOperandConstraint(OpI, MCOI::TIED_TO);
			if (DefIdx != -1 && !I.isRegTiedToUseOperand(DefIdx))
				I.tieOperands(DefIdx, OpI);
		}
	}
	return true;
}
ConstantInt* machineOperandTryGetConst(LLVMContext &Context,
		MachineRegisterInfo &MRI, MachineOperand &MO) {
	if (MO.isReg() && MO.getReg()) {
		if (auto VRegVal = getAnyConstantVRegValWithLookThrough(MO.getReg(),
				MRI)) {
			assert(VRegVal.hasValue());
			auto *CI = ConstantInt::get(Context, VRegVal->Value);
			return CI;
		}
	}
	return nullptr;
}
void selectInstrArg(MachineFunction &MF, MachineInstr &I,
		MachineInstrBuilder &MIB, MachineRegisterInfo &MRI,
		MachineOperand &MO) {
	if (MO.isReg() && MO.getReg()) {
		if (MO.isDef()) {
			MIB.addDef(MO.getReg());
		} else if (auto VRegVal = getAnyConstantVRegValWithLookThrough(
				MO.getReg(), MRI)) {
			assert(VRegVal.hasValue());
			auto &C = MF.getFunction().getContext();
			auto *CI = ConstantInt::get(C, VRegVal->Value);
			MIB.addCImm(CI);
		} else {
			MIB.addUse(MO.getReg());
		}
	} else {
		MIB.add(MO);
	}
}
void selectInstrArgs(MachineInstr &I, MachineInstrBuilder &MIB,
		bool firstIsDef) {
	MachineBasicBlock &MBB = *I.getParent();
	MachineFunction &MF = *MBB.getParent();
	MachineRegisterInfo &MRI = MF.getRegInfo();

	for (unsigned OpI = 0, OpE = I.getNumExplicitOperands(); OpI != OpE;
			++OpI) {
		MachineOperand &MO = I.getOperand(OpI);
		// if operand is a constant value use constant value directly
		if (OpI == 0 && firstIsDef) {
			assert(MO.isReg());
			assert(MO.isDef());
			MIB.addDef(MO.getReg());
			continue;
		}
		selectInstrArg(MF, I, MIB, MRI, MO);
	}
	MIB.cloneMemRefs(I); // copy part behind :: in "G_LOAD %0:anyregcls :: (volatile load (s4) from %ir.dataIn)"
}
bool GenericFpgaTargetInstructionSelector::finalizeReplacementOfInstruction(
		MachineInstrBuilder &MIB, MachineInstr &I) {
	if (!constrainInstRegOperands(*MIB.getInstr(), TII, TRI, RBI))
		return false;
	I.eraseFromParent();
	return true;
}
bool GenericFpgaTargetInstructionSelector::select(MachineInstr &I) {
	/*
	 * After selection process finish each VReg has to have some TargetRegisterClass assigned.
	 * */
	assert(I.getParent() && "Instruction should be in a basic block!");
	assert(
			I.getParent()->getParent()
					&& "Instruction should be in a function!");

	MachineBasicBlock &MBB = *I.getParent();
	MachineFunction &MF = *MBB.getParent();
	MachineRegisterInfo &MRI = MF.getRegInfo();
	auto Opc = I.getOpcode();
	if (!isPreISelGenericOpcode(Opc)) {
		// Certain non-generic instructions also need some special handling.
		return true;
	}

	if (selectImpl(I, *CoverageInfo))
		return true;

	const TargetRegisterClass &RC = GenericFpga::AnyRegClsRegClass;

	MachineIRBuilder Builder(I);
	//llvm::errs() << "GenericFpgaTargetInstructionSelector::select: "
	//		<< TII.getName(Opc) << "\n";
	using namespace TargetOpcode;
	switch (Opc) {
	case G_PHI: {
		// PHI value args must be registers otherwise OptimizePHIs will fail.
		//MachineIRBuilder Builder(I);
		//auto MIB = Builder.buildInstr(PHI);
		//MIB.getInstr()->setDesc(TII.get(PHI));
		//I.setDesc(TII.get(PHI));
		//
		//Register DstReg = I.getOperand(0).getReg();
		//
		//selectInstrArgs(I, MIB, true);
		//if (!RBI.constrainGenericRegister(DstReg, RC, MRI)) {
		//	break;
		//}
		//if (!constrainInstRegOperands(*MIB.getInstr(), TII, TRI, RBI))
		//	return false;
		//I.eraseFromParent();
		I.setDesc(TII.get(PHI));

		Register DstReg = I.getOperand(0).getReg();
		if (!RBI.constrainGenericRegister(DstReg, RC, MRI)) {
			break;
		}
		if (!constrainInstRegOperands(I, TII, TRI, RBI))
			return false;
		return true;
	}
	case G_CONSTANT: {
		unsigned NewOpc = G_CONSTANT;
		auto MIB = Builder.buildInstr(NewOpc);
		selectInstrArgs(I, MIB, true);
		auto o0 = MIB.getInstr()->getOperand(0).getReg();
		MRI.setType(o0, LLT::scalar(I.getOperand(1).getCImm()->getBitWidth()));
		return finalizeReplacementOfInstruction(MIB, I);
	}
	case G_LOAD:
	case G_STORE:
		return select_G_LOAD_or_G_STORE(MF, MRI, Builder, I);

	case G_ADD:
	case G_AND:
	case G_BR:
	case G_BRCOND:
	case G_EXTRACT:
	case G_ICMP:
	case G_IMPLICIT_DEF: // used for function arguments
	case G_INDEXED_LOAD:
	case G_INDEXED_STORE:
	case G_MERGE_VALUES:
	case G_PTR_ADD:
	case G_MUL:
	case G_OR:
	case G_SELECT:
	case G_SUB:
	case G_XOR: {
		auto _Opc = Opc;
		switch (Opc) {
		case G_EXTRACT:
			_Opc = GenericFpga::GENFPGA_EXTRACT;
			break;
		case G_MERGE_VALUES:
			_Opc = GenericFpga::GENFPGA_MERGE_VALUES;
			break;
		}
		auto MIB = Builder.buildInstr(_Opc);
		selectInstrArgs(I, MIB, Opc != G_BRCOND && Opc != G_BR);

		// add extra type spec operands if required
		if (Opc == G_EXTRACT) {
			// dst, src, offset, dstWidth, (dst, src and offset already added)
			MIB.addImm(MRI.getType(I.getOperand(0).getReg()).getSizeInBits()); // add dstWidth
		} else if (Opc == G_MERGE_VALUES) {
			// dst, src{N}, width{N}, (dst, srcs were already added)
			for (unsigned i = 1; i < I.getNumOperands(); i++) {
				MIB.addImm(
						MRI.getType(I.getOperand(i).getReg()).getSizeInBits()); // add dstWidth
			}
		}

		return finalizeReplacementOfInstruction(MIB, I);
	}
	case G_SEXT:
		return select_G_SEXT(MF, MRI, Builder, I);
	case G_ZEXT:
		return select_G_ZEXT(MF, MRI, Builder, I);
	case G_SHL:
		return select_G_SHL(MF, MRI, Builder, I);

	default:
		return false; // some unknown operands (on error it will be printed immediately by caller)
	}

	return false; // all is selected because this is just a dummy selector
}

uint64_t log2ceil(uint64_t x) {
	// https://graphics.stanford.edu/~seander/bithacks.html#IntegerLogObvious
	uint64_t v = (x - 1); // word to find the log base 2 of
	uint64_t r = 0; // r will be lg(v)
	while (v > 0) {
		v >>= 1;
		r++;
	}
	return r;
}
bool isPow2(uint64_t x) {
	if (x == 0)
		return false;

	while (x != 1) {
		if ((x & 1) != 0)
			return false;
		x >>= 1;
	}
	return true;
}
bool GenericFpgaTargetInstructionSelector::select_G_LOAD_or_G_STORE(
		MachineFunction &MF, MachineRegisterInfo &MRI, MachineIRBuilder &MIRB,
		MachineInstr &I) {

	auto Opc = I.getOpcode();
	unsigned NewOpc;
	switch (Opc) {
	case TargetOpcode::G_LOAD:
		NewOpc = GenericFpga::GENFPGA_CLOAD;
		break;
	case TargetOpcode::G_STORE:
		NewOpc = GenericFpga::GENFPGA_CSTORE;
		break;
	default:
		llvm_unreachable(nullptr);
	}
	//for (auto MO: I.memoperands()) {
	//	MO->getAAInfo()
	//}
	// resolve addr, index
	MachineOperand &addrMO = I.getOperand(1);
	assert(
			addrMO.isReg()
					&& "Must be the register because we do not have global address space and we can not just dereference address constant.");
	assert(
			MRI.hasOneDef(addrMO.getReg())
					&& "Otherwise not implemented, it is required to rewrite address mux to multiple store/load instructions.");
	// val/dst, addr, index, cond
	auto MIB = MIRB.buildInstr(NewOpc);
	selectInstrArg(MF, I, MIB, MRI, I.getOperand(0)); // val/dst - copy as it is


	MachineInstr *addrDef = MRI.getOneDef(addrMO.getReg())->getParent();
	switch (addrDef->getOpcode()) {
	case GenericFpga::GENFPGA_ARG_GET: {
		// this is just original base address
		selectInstrArg(MF, I, MIB, MRI, addrMO); // base address
		MIB.addImm(0); // index
		break;
	}
	case TargetOpcode::G_PTR_ADD: {
		// [todo] slice the index during instr. selection so we do have a minimal width and value without size multiplier
		MachineOperand &baseAddr = addrDef->getOperand(1);
		selectInstrArg(MF, I, MIB, MRI, baseAddr); // base address
		auto fnArgI = MRI.getOneDef(baseAddr.getReg())->getParent()->getOperand(
				1).getImm();
		auto a = MF.getFunction().getArg(fnArgI);
		auto argT = a->getType()->getNonOpaquePointerElementType();
		assert(
				argT->isArrayTy()
						&& "Must be the array otherwise we would not have index in the first place");
		const DataLayout & DL = MF.getFunction().getParent()->getDataLayout();
		TypeSize itemSize =  DL.getTypeAllocSize(argT->getArrayElementType());

		auto arraySize = argT->getArrayNumElements();
		auto indexWidth = log2ceil(arraySize);
		assert(indexWidth > 0);

		if (isPow2(itemSize)) {
			// set to insert before newly added GENFPGA_CLOAD/GENFPGA_STORE
			MIRB.setInsertPt(*MIRB.getInsertPt()->getParent(), --MIRB.getInsertPt());
			// dst, src, offset, dstWidth
			MachineInstrBuilder indexMIB = MIRB.buildInstr(
							GenericFpga::GENFPGA_EXTRACT);
			Register indexReg = MRI.createGenericVirtualRegister(
					LLT::scalar(indexWidth));
			indexMIB.addDef(indexReg);
			selectInstrArg(MF, I, indexMIB, MRI, addrDef->getOperand(2)); // index as src
			indexMIB.addImm(log2ceil(itemSize)); // offset
			indexMIB.addImm(indexWidth); // dstWidth
			MIB.addReg(indexReg); // index
		} else {
			llvm_unreachable("NotImplemented, extract the multiplier from the index");
		}

		break;
	}
	default:
		errs() << I << " address operand defined by:\n" << *addrDef;
		llvm_unreachable(
				"Unknonwn instruction specifing address for load or store");
	}

	MIB.addImm(1); // cond
	MIB.cloneMemRefs(I); // copy part behind :: in "G_LOAD %0:anyregcls :: (volatile load (s4) from %ir.dataIn)"

	return finalizeReplacementOfInstruction(MIB, I);
}

bool GenericFpgaTargetInstructionSelector::select_G_SHL(MachineFunction &MF,
		MachineRegisterInfo &MRI, MachineIRBuilder &MIRB, MachineInstr &I) {
	auto &Context = MF.getFunction().getContext();
	auto &lhs = I.getOperand(1);
	auto &rhs = I.getOperand(2);
	ConstantInt *lhsConst = machineOperandTryGetConst(Context, MRI, lhs);
	ConstantInt *rhsConst = machineOperandTryGetConst(Context, MRI, rhs);
	if (lhsConst && rhsConst) {
		// if lhs and rhs are constants we resolve immediately
		APInt v = lhsConst->getValue();
		MachineInstrBuilder MIB = MIRB.buildConstant(I.getOperand(0).getReg(),
				v << rhsConst->getValue());
		return finalizeReplacementOfInstruction(MIB, I);

	} else if (rhsConst) {
		// if rhs is constant we convert this to a concatenation with zeros on right (lower) side
		MachineInstrBuilder MIB0 = MIRB.buildInstr(
				GenericFpga::GENFPGA_EXTRACT);
		unsigned paddingWidth = rhsConst->getZExtValue();
		APInt padding(paddingWidth, 0);
		auto *paddingCI = ConstantInt::get(Context, padding);
		unsigned dstWidth =
				MRI.getType(I.getOperand(0).getReg()).getSizeInBits();
		// dst, src, offset, dstWidth
		Register upperBits = MRI.createGenericVirtualRegister(
				LLT::scalar(dstWidth - paddingWidth));
		MIB0.addDef(upperBits);
		selectInstrArg(MF, I, MIB0, MRI, I.getOperand(1));
		// lhs
		MIB0.addImm(0);
		MIB0.addImm(dstWidth - paddingWidth);
		if (!constrainInstRegOperands(*MIB0.getInstr(), TII, TRI, RBI))
			return false;

		MachineInstrBuilder MIB = MIRB.buildInstr(
				GenericFpga::GENFPGA_MERGE_VALUES);
		MIB.add(I.getOperand(0)); // dst
		MIB.addCImm(paddingCI);
		MIB.addReg(upperBits); // lhs
		MIB.addImm(paddingWidth);
		MIB.addImm(dstWidth - paddingWidth);
		return finalizeReplacementOfInstruction(MIB, I);

	} else if (lhsConst) {
		// if lhs is constant we generate mux for all possible constant values of the shift
		return false;
		//assert(false && "NotImplemented");
	} else {
		// if lhs and rhs are not constants we have to create mux for every possible value
		return false;
		//assert(false && "NotImplemented");
	}
}
/*
 * Convert G_SEXT to concatenation of msb bits and original src.
 * */
bool GenericFpgaTargetInstructionSelector::select_G_SEXT(MachineFunction &MF,
		MachineRegisterInfo &MRI, MachineIRBuilder &MIRB, MachineInstr &I) {
	auto &Op0 = I.getOperand(0);
	unsigned dstWidth = MRI.getType(Op0.getReg()).getSizeInBits();
	unsigned srcWidth = MRI.getType(I.getOperand(1).getReg()).getSizeInBits();
	// add leading 0s
	unsigned prefixWidth = dstWidth - srcWidth;

	MachineInstrBuilder msbMIB = MIRB.buildInstr(GenericFpga::GENFPGA_EXTRACT);
	// dst, src, offset, dstWidth
	Register msb = MRI.createGenericVirtualRegister(LLT::scalar(1));
	msbMIB.addDef(msb);
	selectInstrArg(MF, I, msbMIB, MRI, I.getOperand(1));
	// lhs
	msbMIB.addImm(srcWidth - 1);
	msbMIB.addImm(1);
	if (!constrainInstRegOperands(*msbMIB.getInstr(), TII, TRI, RBI))
		return false;

	MachineInstrBuilder MIB = MIRB.buildInstr(
			GenericFpga::GENFPGA_MERGE_VALUES);
	MIB.addDef(Op0.getReg(), Op0.getTargetFlags());
	selectInstrArg(MF, I, MIB, MRI, I.getOperand(1));
	for (unsigned i = 0; i < prefixWidth; i++) {
		MIB.addReg(msb);
	}
	MIB.addImm(srcWidth);
	for (unsigned i = 0; i < prefixWidth; i++) {
		MIB.addImm(1);
	}
	return finalizeReplacementOfInstruction(MIB, I);
}
/*
 * Convert G_ZEXT to concatenation of zeros and original src.
 * */
bool GenericFpgaTargetInstructionSelector::select_G_ZEXT(MachineFunction &MF,
		MachineRegisterInfo &MRI, MachineIRBuilder &MIRB, MachineInstr &I) {
	MachineInstrBuilder MIB = MIRB.buildInstr(
			GenericFpga::GENFPGA_MERGE_VALUES);
	auto &Op0 = I.getOperand(0);
	MIB.addDef(Op0.getReg(), Op0.getTargetFlags());
	unsigned dstWidth = MRI.getType(Op0.getReg()).getSizeInBits();
	unsigned srcWidth = MRI.getType(I.getOperand(1).getReg()).getSizeInBits();
	// add leading 0s
	auto &C = MF.getFunction().getContext();
	unsigned PrefixWidth = dstWidth - srcWidth;
	APInt _Prefix(PrefixWidth, 0);
	auto *Prefix = ConstantInt::get(C, _Prefix);
	selectInstrArg(MF, I, MIB, MRI, I.getOperand(1));
	MIB.addCImm(Prefix);
	MIB.addImm(srcWidth);
	MIB.addImm(PrefixWidth);
	return finalizeReplacementOfInstruction(MIB, I);
}

namespace llvm {
InstructionSelector*
createGenericFpgaInstructionSelector(const GenericFpgaTargetMachine &TM,
		GenericFpgaTargetSubtarget &Subtarget,
		GenericFpgaRegisterBankInfo &RBI) {
	return new GenericFpgaTargetInstructionSelector(TM, Subtarget, RBI);
}
} // end namespace llvm
