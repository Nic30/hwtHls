#include <hwtHls/llvm/Transforms/PruneLoopPhiDeadIncomingValuesPass/PruneLoopPhiDeadIncomingValuesPass.h>
#include <hwtHls/llvm/Transforms/PruneLoopPhiDeadIncomingValuesPass/KnownValue.h>
#include <hwtHls/llvm/targets/intrinsic/bitrange.h>
#include <hwtHls/llvm/hashUtils.h>

#include <unordered_set>
#include <unordered_map>
#include <vector>

#include <llvm/Analysis/LoopAnalysisManager.h>
#include <llvm/Analysis/LoopInfo.h>
#include <llvm/Analysis/MemorySSA.h>
#include <llvm/IR/Constants.h>

using namespace llvm;

#define DEBUG_TYPE "prune-loop-phi-dead-incoming-values"

namespace hwtHls {

/* skipping phis, no load/store, recognize only subset of instructions
 * :param frameStack: vector holding values resolved in individual blocks
 */
void collectReachableBlocks(InBlockValuesStack &frameStack, LoopInfo &LI,
		const Loop &ParentLoop, bool isInitialEnter, BasicBlock &PredBB,
		BasicBlock &BB, std::unordered_set<BasicBlock*> &reachedBlocks,
		std::unordered_set<Loop::Edge> &reachedEdges) {
	reachedBlocks.insert(&BB);
	reachedEdges.insert( { &PredBB, &BB });

	if (isInitialEnter)
		assert(frameStack.size() == 0);
	if (!ParentLoop.contains(&BB))
		return; // this function only evaluates body of parent function
	auto *L = LI.getLoopFor(&BB);
	if (L != &ParentLoop) {
		assert(
				L->getHeader() == &BB
						&& "Only natural loops entered trough header");
		// case for enter to next loop
		// do not analyze child loop and assume all values generated by child loop as unknown
		SmallVector<Loop::Edge> ExitEdges;
		L->getExitEdges(ExitEdges);
		for (auto E : ExitEdges) {
			collectReachableBlocks(frameStack, LI, ParentLoop, false, *E.first,
					*E.second, reachedBlocks, reachedEdges);
		}
		return;
	} else if (!isInitialEnter && &BB == L->getHeader()) {
		// not continue in another iteration of parent loop
		return;
	}

	PushNewBlockValueFrame _bbValues(frameStack, PredBB, BB);
	auto callTryEvalBlock = [&](BasicBlock *SucBB) {
		collectReachableBlocks(frameStack, LI, ParentLoop, false, BB, *SucBB,
				reachedBlocks, reachedEdges);
	};
	assert(frameStack.size());
	for (auto IIt = BB.getFirstNonPHI()->getIterator(); IIt != BB.end();
			++IIt) {
		auto *I = &*IIt;
		if (I->isTerminator()) {
			if (auto *Br = dyn_cast<BranchInst>(I)) {
				if (Br->isConditional()) {
					auto C = Br->getCondition();
					auto CVal = findValueInStack(frameStack, C);
					bool isUnknown = CVal.hasNoSpecificConstValue();
					if (isUnknown || CVal.isNonZero()) {
						callTryEvalBlock(Br->getSuccessor(0));
					}
					if (isUnknown || CVal.isZero()) {
						callTryEvalBlock(Br->getSuccessor(1));
					}
				} else {
					callTryEvalBlock(Br->getSuccessor(0));
				}

			} else if (auto *SW = dyn_cast<SwitchInst>(I)) {
				auto C = SW->getCondition();
				auto CVal = findValueInStack(frameStack, C);
				bool isUnknown = CVal.hasNoSpecificConstValue();
				bool anyMatch = false;
				for (auto &Case : SW->cases()) {
					auto V = Case.getCaseValue();
					KnownValue VVal = CVal.resolveICmp(CmpInst::ICMP_EQ,
							findValueInStack(frameStack, V), nullptr);
					if (VVal.hasNoSpecificConstValue()) {
						callTryEvalBlock(Case.getCaseSuccessor());
					} else if (VVal.isNonZero()) {
						callTryEvalBlock(Case.getCaseSuccessor());
						anyMatch = true;
						break;
					}
				}
				if (isUnknown || !anyMatch) {
					callTryEvalBlock(SW->getDefaultDest());
				}

			} else {
				llvm_unreachable(
						"NotImplementedError: unknown terminator type");
			}
		}
		std::optional<KnownValue> newVal;
		if (auto C = dyn_cast<CallInst>(I)) {
			if (IsBitConcat(C)) {
				SmallVector<KnownValue> ops;
				for (auto &O : C->args()) {
					auto KV = findValueInStack(frameStack, O.get());
					ops.push_back(std::move(KV));
				}
				newVal = KnownValue::resolveBitConcat(ops, *C);
			} else if (IsBitRangeGet(C)) {
				auto o0 = findValueInStack(frameStack, I->getOperand(0));
				auto o1 = findValueInStack(frameStack, I->getOperand(1));
				newVal = o0.resolveBitRangeGet(o1, *C);
			} else {
				// can not resolve, assume unknown specific value, noted as I itself
				newVal = KnownValue::compute(*I);
			}
		} else {
			switch (I->getNumOperands()) {
			case 1: {
				auto o0 = findValueInStack(frameStack, I->getOperand(0));
				switch (I->getOpcode()) {
				case Instruction::ZExt:
					newVal = o0.resolveZExt(o0, *dyn_cast<ZExtInst>(I));
					break;
				case Instruction::SExt:
					newVal = o0.resolveSExt(o0, *dyn_cast<SExtInst>(I));
					break;
				case Instruction::BitCast:
					newVal = o0.resolveBitCast(o0, *dyn_cast<BitCastInst>(I));
					break;
				}
				break;
			}
			case 2: {
				KnownValue o0 = findValueInStack(frameStack, I->getOperand(0));
				KnownValue o1 = findValueInStack(frameStack, I->getOperand(1));

				switch (I->getOpcode()) {
				case Instruction::ICmp: {
					auto _I = dyn_cast<ICmpInst>(I);
					newVal = o0.resolveICmp(_I->getPredicate(), o1, _I);
					break;
				}
				case Instruction::And:
					newVal = o0.resolveAnd(o1, *I);
					break;
				case Instruction::Or:
					newVal = o0.resolveOr(o1, *I);
					break;
				case Instruction::Xor:
					newVal = o0.resolveXor(o1, *I);
					break;
				case Instruction::LShr:
					newVal = o0.resolveLShr(o1, *I);
					break;
				case Instruction::AShr:
					newVal = o0.resolveAShr(o1, *I);
					break;
				case Instruction::Shl:
					newVal = o0.resolveShl(o1, *I);
					break;
				default:
					newVal = KnownValue::compute(*I);
				}
				break;
			}
			case 3: {
				KnownValue o0 = findValueInStack(frameStack, I->getOperand(0));
				KnownValue o1 = findValueInStack(frameStack, I->getOperand(1));
				KnownValue o2 = findValueInStack(frameStack, I->getOperand(2));
				switch (I->getOpcode()) {
				case Instruction::Select: {
					auto _I = dyn_cast<SelectInst>(I);
					newVal = o0.resolveSelect(o1, o2, *_I);
					break;
				}
				default:
					newVal = KnownValue::compute(*I);
				}
				break;
			}
			}
			auto &Vals = frameStack.back(); // this can not be hoisted because vector memory may reallocate
			// if child blocks are adding into it
			if (newVal.has_value()) {
				Vals.insert_or_assign(I, newVal.value());
			} else {
				Vals.insert_or_assign(I, KnownValue::compute(*I));
			}
		}
	}
}

/*
 * :param usedValues: values which are known to be used be something which has some effect
 * 	and thus can not be ignored
 * :param seenValues: values which were resolved to be used or unused
 * */
bool collectHeaderPhiValuesUsedWithSomeEffect_forInstruction(LoopInfo &LI,
		const Loop &L, const std::unordered_set<BasicBlock*> &reachedBlocks,
		const std::unordered_set<Loop::Edge> &reachedEdges,
		std::unordered_set<Value*> &usedValues,
		std::unordered_set<Value*> &seenValues, Instruction &I) {
	if (seenValues.contains(&I)) {
		return usedValues.contains(&I);
	}
	// :note: we can not include into seenValues immediately because it could make some other values used by this value
	//   to be marked as unused if they are probed until this value is resolved

	// search user until some user is resolved to be used
	for (auto &U : I.uses()) {
		Value *UV = U.getUser();
		if (usedValues.contains(UV)) {
			seenValues.insert(&I);
			usedValues.insert(&I);
			return true; // known to be used because user is used
		}
		if (auto UserI = dyn_cast<Instruction>(UV)) {
			auto *UserBB = UserI->getParent();
			if (UserI->mayHaveSideEffects() || UserI->isTerminator()
					|| UserI->isVolatile()) {
				// used by something with side effect => can not be ignored => is used
				usedValues.insert(&I);
				seenValues.insert(&I);
				return true;
			}

			if (L.contains(UserI->getParent())) {
				if (!reachedBlocks.contains(UserBB)) {
					// not important because loop with specified loop input variables the body can not reach
					continue;
				}
				if (auto *UserPhi = dyn_cast<PHINode>(UserI)) {
					// if is phi in loop header
					if (LI.getLoopFor(UserBB)->getHeader() == UserBB) {
						usedValues.insert(&I);
						seenValues.insert(&I);
						return true;
					}

					// if it is phi it is necessary to check if value is comming from block which is reachable
					auto *PredBB = UserPhi->getIncomingBlock(
							U.getOperandNo());
					if (!reachedEdges.contains({PredBB, UserBB}) && L.contains(PredBB)) {
						// :note: L.contains(PredBB) to cover case for L header initial values
						continue;// value is not actually used because predecessor can not be reached
					}
				}
				// search if user is used
				if (!collectHeaderPhiValuesUsedWithSomeEffect_forInstruction(LI,
						L, reachedBlocks, reachedEdges, usedValues, seenValues, *UserI)) {
					continue; // user not used
				}
			}
			// else used outside of loop

		}
		// else user is not instruction which can be ignored

		usedValues.insert(&I);
		seenValues.insert(&I);
		return true; // found to be used by this user
	}
	seenValues.insert(&I);
	// no use has been found
	return false;
}
/*
 * This function is used to search if the value obtained from some
 * specific predecessor of loop header has an effect or is stored somewhere.
 * If the value is not collected to usedValues it means that the incoming value
 * in loop header phi may be discarded.
 *
 * Top-down DFS search for value which are used in some of the cases:
 *  * outside of loop
 *  * inside of a child loop
 *  * in header phi from any reachable block
 *  * in instruction with side effect, LoadInst/StoreInst
 * */
void collectHeaderPhiValuesUsedWithSomeEffect(LoopInfo &LI, const Loop &L,
		const std::unordered_set<BasicBlock*> &reachedBlocks,
		const std::unordered_set<Loop::Edge> &reachedEdges,
		std::unordered_set<Value*> &usedValues) {
	std::unordered_set<Value*> seenValues;
	for (auto &PHI : L.getHeader()->phis()) {
		collectHeaderPhiValuesUsedWithSomeEffect_forInstruction(LI, L,
				reachedBlocks, reachedEdges, usedValues, seenValues, PHI);
	}
}

bool pruneLoopPhiDeadIncomingValues(LoopInfo &LI, const Loop &L) {
	auto Header = L.getHeader();
	auto Phis = Header->phis();
	if (Phis.begin() == Phis.end()) {
		return false;
	}
	// :note: The value of phi is likely to be used in phis.
	//         we have to resolve which paths trough the CFG are possible
	//   to be able to resolve which values of phis are used
	bool Changed = false;
	for (auto PredBB : predecessors(Header)) {
		SmallVector<PHINode*> phisToCheck;
		for (auto &PHI : Phis) {
			auto V = PHI.getIncomingValueForBlock(PredBB);
			if (V == &PHI) {
				// this would require more complex check to see if value is used in any iteration
				continue;
			} else if (isa<UndefValue>(V) || isa<PoisonValue>(V)) {
				// check is not required because the value does not hold any specific value to be discarded
				continue;
			} else {
				phisToCheck.push_back(&PHI);
			}
		}

		if (phisToCheck.size()) {
			InBlockValuesStack frameStack;
			std::unordered_set<BasicBlock*> reachedBlocks;
			std::unordered_set<Loop::Edge> reachedEdges;

			collectReachableBlocks(frameStack, LI, L, true, *PredBB, *Header,
					reachedBlocks, reachedEdges);
			assert(frameStack.empty());

			std::unordered_set<Value*> usedValues;
			collectHeaderPhiValuesUsedWithSomeEffect(LI, L, reachedBlocks,
					reachedEdges, usedValues);

			for (auto *PHI : phisToCheck) {
				if (usedValues.find(PHI) == usedValues.end()) {
					PHI->setIncomingValueForBlock(PredBB,
							PoisonValue::get(PHI->getType()));
					Changed = true;
				}
			}
		}
	}
	return Changed;
}

bool PruneLoopPhiDeadIncomingValuesPass_forLoop(LoopInfo &LI, const Loop &L) {
	bool Changed = false;
	// run on children first because we may be able to cancel some false uses
	// (however there may still be false use something from child loop in this loop)
	for (auto *SL : L.getSubLoops()) {
		Changed |= PruneLoopPhiDeadIncomingValuesPass_forLoop(LI, *SL);
	}
	Changed |= pruneLoopPhiDeadIncomingValues(LI, L);
	return Changed;
}

llvm::PreservedAnalyses PruneLoopPhiDeadIncomingValuesPass::run(
		llvm::Function &F, llvm::FunctionAnalysisManager &AM) {
	bool Changed = false;
	auto *LI = &AM.getResult<LoopAnalysis>(F);
	for (const Loop *L : *LI) {
		Changed |= PruneLoopPhiDeadIncomingValuesPass_forLoop(*LI, *L);
	}
	if (Changed) {
		auto PA = getLoopPassPreservedAnalyses();
		PA.preserveSet<CFGAnalyses>();
		PA.preserve<MemorySSAAnalysis>();
		return PA;
	} else {
		return PreservedAnalyses::all();
	}
}
}
